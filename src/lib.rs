//! This library parses JSON generated by LDtk (Level Designers ToolKit) for use in Rust.
//! It is designed to be usable in any Rust program, including all game frameworks.
//!
//! Most users will want to start by reviewing the top level Project struct and 
//! in particular the Project::new() method. Calling this method will load in
//! all of your LDtk data. See the library's /examples subdirectory for more
//! detailed examples.
//!
//!     Project::new(f: String) --- loads all the data
//!     Project::load_project(f: String) --- loads only the project file
//!     Level::new(f: String) --- loads a single external level file
//!

mod json_0_9_0;
use std::{fs::File, path::Path};

pub use json_0_9_0::*;

// this struct name has to match the auto-generated top-level struct.
// Currently mirroring the LDTK Haxe API as best I can figure out.
impl Project {

    pub fn new(f: String) -> Self {
        let mut o = Project::load_project(f.clone());
        if o.external_levels {
            o.load_external_levels(f);
        }
        o
    }

    // Read in an LDTK project file
    pub fn load_project(f: String) -> Self {
        let json_file_path = Path::new(&f);
        let file = File::open(json_file_path).expect("project file not found");
        let o: Project = serde_json::from_reader(file).expect("error while reading");
        o
    }

    // Remove any items in the project.levels Vec ... useful when you
    // get external file info and want to replace the items with more
    // complete data extrated from the files.
    pub fn clear_levels(&mut self) {
        self.levels = Vec::new();
    }

    // Read in ALL the external level files referred to in an LDTK Project
    pub fn load_external_levels(&mut self, f: String) {
        // check to make sure there ARE separate levels
        // if not, then likely the call to this method
        // should do nothing because you already have
        // the levels.
        if self.external_levels {
            // get all the file names
            let mut all_level_files: Vec<String> = Vec::new();
            for level in self.levels.iter_mut() {
                let level_file_path = level.external_rel_path.as_ref().expect("missing level");
                all_level_files.push(level_file_path.to_string());
            }

            // get rid of existing levels (which don't have much data)
            self.clear_levels();

            // now add each of them to our struct
            for file in all_level_files.iter() {
                let mut full_path: String = String::new();
                let parent = Path::new(&f).parent().unwrap().to_str().unwrap(); 
                full_path.push_str(parent);
                full_path.push_str("/");
                full_path.push_str(&file.to_string());
                println!("opening {:#?}", full_path);
                let level_ldtk = Level::new(full_path);
                self.levels.push(level_ldtk);
            }
        }
    }

    pub fn get_level(&self, uid: i64) -> Option<&Level> {
        for level in self.levels.iter() {
            if level.uid == uid {
                return Some(level);
            }
        }
        None
    }
}

impl Level {
    // Read in a single external LDTK level file
    pub fn new(f: String) -> Self {
        let json_file_path = Path::new(&f);
        let file = File::open(json_file_path).expect("level file not found");
        let o: Level = serde_json::from_reader(file).expect("error while reading");
        o
    }
}

#[deprecated = "Use Project instead of LdtkJson to match LDtk documentation."]
pub struct LdtkJson;

// supports legacy name from 0.2.0 as well as
// some QuickType examples over at LDTK.
#[allow(deprecated)]
impl LdtkJson {
    pub fn new(f: String) -> Project {
        Project::new(f)
    }
}
